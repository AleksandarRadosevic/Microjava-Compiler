




package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal Integer NUMBER;
terminal String IDENT;
terminal PROG, LBRACECURLY, RBRACECURLY, CONST, ASSIGN, CHARCONST, BOOLCONST, EQUAL, NOTEQUAL, GREATER, GREATEREQUAL;
terminal COMMA, CLASS, EXTENDS, RECORD, LPAREN, RPAREN, VOID, PRINT, GOTO, AND, NEW, DOT, PLUS, MINUS, MUL, DIV, MOD, COLON;
terminal IF, SEMICOLON, DO, WHILE, BREAK, CONTINUE, RETURN, READ, LBRACE, RBRACE, INCREMENT, DECREMENT,LOWER, LOWEREQUAL, OR, ELSE;

nonterminal Program Program;
nonterminal DeclarationList DeclarationList;
nonterminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
nonterminal ClassDecl ClassDecl;
nonterminal RecordDecl RecordDecl;
nonterminal Type Type;
nonterminal ConstVal ConstVal;
nonterminal ConstDeclList ConstDeclList;
nonterminal MethodDecl MethodDecl;
nonterminal OptionalBraces OptionalBraces;
nonterminal VarDeclList VarDeclList;
nonterminal ConstDeclRepeat ConstDeclRepeat;
nonterminal VarDeclRepeat VarDeclRepeat;
nonterminal OptionalExtends OptionalExtends;
nonterminal DeclListVar DeclListVar;
nonterminal DeclList DeclList;
nonterminal OptConstructorMethod OptConstructorMethod;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal OptionalConstructorDecl OptionalConstructorDecl;
nonterminal DeclListMethod DeclListMethod;
nonterminal StatementList StatementList;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal FormParsOptional FormParsOptional;
nonterminal Statement Statement;
nonterminal FormPars FormPars;
nonterminal Pars Pars;
nonterminal ParsList ParsList;
nonterminal SingleStatement SingleStatement;
nonterminal Label Label;
nonterminal LabelColon LabelColon;
nonterminal Condition Condition;
nonterminal OptionalElse OptionalElse;
nonterminal Designator Designator;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DesignatorStatementElements DesignatorStatementElements;
nonterminal ExprCommaList ExprCommaList;
nonterminal Expr Expr;
nonterminal OptionalNumConst OptionalNumConst;
nonterminal Statements Statements;
nonterminal OptionalExpression OptionalExpression;
nonterminal ActParsOptional ActParsOptional;
nonterminal ActPars ActPars;
nonterminal CondTerm CondTerm;
nonterminal CondTermListOr CondTermListOr;
nonterminal CondFactListAnd CondFactListAnd;
nonterminal CondFact CondFact;
nonterminal RelopOprOptional RelopOprOptional;
nonterminal Relop Relop;
nonterminal OptionalMinus OptionalMinus;
nonterminal Term Term;
nonterminal AddopTermList AddopTermList;
nonterminal Addop Addop;
nonterminal Factor Factor;
nonterminal MulopFactorList MulopFactorList;
nonterminal Mulop Mulop;
nonterminal ActParsBracesOptional ActParsBracesOptional;
nonterminal ExprBracesOptional ExprBracesOptional;
nonterminal IdentList IdentList;
nonterminal DotOrExpr DotOrExpr;
nonterminal Assignop Assignop;


Program ::= (Programc) PROG IDENT:I1 DeclarationList:D2 LBRACECURLY DeclListMethod:D3 RBRACECURLY {: RESULT=new Programc(I1, D2, D3); RESULT.setLine(I1left); :};

DeclarationList ::= (DeclarationListc) DeclarationList:D1 DeclList:D2 {: RESULT=new DeclarationListc(D1, D2); RESULT.setLine(D1left); :}
				| (NoDeclarations) {: RESULT=new NoDeclarations(); :} /* epsilon */;
				
DeclList ::= (DeclListc)  
				ConstDecl:C1 {: RESULT=new DeclListc(C1); RESULT.setLine(C1left); :}  |
				VarDecl:V1 {: RESULT=new DeclListDerived1(V1); RESULT.setLine(V1left); :}    | 
				ClassDecl:C1 {: RESULT=new DeclListDerived2(C1); RESULT.setLine(C1left); :}  | 
				RecordDecl:R1 {: RESULT=new DeclListDerived3(R1); RESULT.setLine(R1left); :};
			

ConstDecl ::= (ConstDeclc) CONST Type:constType ConstDeclRepeat:C1 ConstDeclList:C2 SEMICOLON {: RESULT=new ConstDeclc(constType, C1, C2); RESULT.setLine(constTypeleft); :};

ConstDeclRepeat ::= (ConstDeclRepeatc) IDENT:I1 ASSIGN ConstVal:C2 {: RESULT=new ConstDeclRepeatc(I1, C2); RESULT.setLine(I1left); :};

ConstVal ::= (ConstValc) NUMBER:N1 {: RESULT=new ConstValc(N1); RESULT.setLine(N1left); :} | CHARCONST {: RESULT=new ConstValDerived1(); :} | BOOLCONST {: RESULT=new ConstValDerived2(); :};

ConstDeclList ::= (ConstDeclListc) ConstDeclList:C1 ConstDeclRepeat:C2 {: RESULT=new ConstDeclListc(C1, C2); RESULT.setLine(C1left); :}  
				| (NoConstDecl) {: RESULT=new NoConstDecl(); :} /* epsilon */;
	

VarDecl ::= (VarDeclc) Type:varType VarDeclRepeat:V1 VarDeclList:V2 SEMICOLON {: RESULT=new VarDeclc(varType, V1, V2); RESULT.setLine(varTypeleft); :};

VarDeclRepeat ::= (VarDeclRepeatc) IDENT:I1 OptionalBraces:O2 {: RESULT=new VarDeclRepeatc(I1, O2); RESULT.setLine(I1left); :};

OptionalBraces ::= (OptionalBracesc) LBRACE RBRACE {: RESULT=new OptionalBracesc(); :} 
				| (NoOptionalBraces) {: RESULT=new NoOptionalBraces(); :} /* epsilon */;

VarDeclList ::= (VarDeclListc) VarDeclList:V1 COMMA VarDeclRepeat:V2 {: RESULT=new VarDeclListc(V1, V2); RESULT.setLine(V1left); :}  
				| (NoVarDeclList) {: RESULT=new NoVarDeclList(); :} /* epsilon */;
	
			
ClassDecl ::= (ClassDeclc) CLASS IDENT:I1 OptionalExtends:O2 LBRACECURLY DeclListVar:D3 OptConstructorMethod:O4 RBRACECURLY {: RESULT=new ClassDeclc(I1, O2, D3, O4); RESULT.setLine(I1left); :};			 

OptionalExtends ::= (OptionalExtendsc) EXTENDS Type:T1 {: RESULT=new OptionalExtendsc(T1); RESULT.setLine(T1left); :}
				| (NoOptionalExtendsc) {: RESULT=new NoOptionalExtendsc(); :} /* epsilon */;
 
DeclListVar ::=	(DeclListVarc) DeclListVar:D1 VarDecl:V2 {: RESULT=new DeclListVarc(D1, V2); RESULT.setLine(D1left); :} 
				| (NoDeclListVar) {: RESULT=new NoDeclListVar(); :} /* epsilon */;	


OptConstructorMethod ::= (OptConstructorMethodc) LBRACECURLY OptionalConstructorDecl:O1 DeclListMethod:D2 RBRACECURLY {: RESULT=new OptConstructorMethodc(O1, D2); RESULT.setLine(O1left); :}
				| (NoOptConstructorMethod) {: RESULT=new NoOptConstructorMethod(); :} /* epsilon */;	
				
OptionalConstructorDecl ::= (OptionalConstructorDeclc) ConstructorDecl:C1 {: RESULT=new OptionalConstructorDeclc(C1); RESULT.setLine(C1left); :}
				| (NoOptionalConstructorDecl) {: RESULT=new NoOptionalConstructorDecl(); :} /* epsilon */;	
				
DeclListMethod ::= (DeclListMethodc) DeclListMethod:D1 MethodDecl:M2 {: RESULT=new DeclListMethodc(D1, M2); RESULT.setLine(D1left); :} 
				| (NoDeclListMethod) {: RESULT=new NoDeclListMethod(); :} /* epsilon */;	


RecordDecl ::= (RecordDeclc) RECORD IDENT:I1 LBRACECURLY DeclListVar:D2 RBRACECURLY {: RESULT=new RecordDeclc(I1, D2); RESULT.setLine(I1left); :};

ConstructorDecl ::= (ConstructorDeclc) IDENT:I1 LPAREN RPAREN DeclListVar:D2 LBRACECURLY StatementList:S3 RBRACECURLY {: RESULT=new ConstructorDeclc(I1, D2, S3); RESULT.setLine(I1left); :};


MethodDecl ::= (MethodDeclc) TypeOrVoid:T1 IDENT:I2 LPAREN FormParsOptional:F3 RPAREN DeclListVar:D4 LBRACECURLY StatementList:S5 RBRACECURLY {: RESULT=new MethodDeclc(T1, I2, F3, D4, S5); RESULT.setLine(T1left); :};

TypeOrVoid ::= (TypeOrVoidc) Type:T1 {: RESULT=new TypeOrVoidc(T1); RESULT.setLine(T1left); :} | VOID {: RESULT=new TypeOrVoidDerived1(); :};

FormParsOptional ::= (FormParsOptionalc) FormPars:F1 {: RESULT=new FormParsOptionalc(F1); RESULT.setLine(F1left); :}
				| (NoFormParsOptional) {: RESULT=new NoFormParsOptional(); :} /* epsilon */;
						
						
FormPars ::= (FormParsc) Pars:P1 ParsList:P2 {: RESULT=new FormParsc(P1, P2); RESULT.setLine(P1left); :};
		
Pars ::= (Parsc) Type:T1 IDENT:I2 OptionalBraces:O3 {: RESULT=new Parsc(T1, I2, O3); RESULT.setLine(T1left); :};

ParsList ::= (ParsListc) ParsList:P1 COMMA Pars:P2 {: RESULT=new ParsListc(P1, P2); RESULT.setLine(P1left); :} 
			| (NoParsList) {: RESULT=new NoParsList(); :} /* epsilon */;

Type ::= (Typec) IDENT:I1 {: RESULT=new Typec(I1); RESULT.setLine(I1left); :};


Statement ::= (Statementc) LabelColon:L1 SingleStatement:S2 {: RESULT=new Statementc(L1, S2); RESULT.setLine(L1left); :} 
			| SingleStatement:S1 {: RESULT=new StatementDerived1(S1); RESULT.setLine(S1left); :}
			| Statements:S1 {: RESULT=new StatementDerived2(S1); RESULT.setLine(S1left); :};


LabelColon ::= (LabelColonc) Label:L1 COLON {: RESULT=new LabelColonc(L1); RESULT.setLine(L1left); :};

SingleStatement ::= (SingleStatementc) DesignatorStatement:D1 SEMICOLON {: RESULT=new SingleStatementc(D1); RESULT.setLine(D1left); :}
				| IF LPAREN Condition:C1 RPAREN Statement:S2 OptionalElse:O3 {: RESULT=new SingleStatementDerived1(C1, S2, O3); RESULT.setLine(C1left); :}
			 	| DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMICOLON {: RESULT=new SingleStatementDerived2(S1, C2); RESULT.setLine(S1left); :}
				| BREAK SEMICOLON {: RESULT=new SingleStatementDerived3(); :}
				| CONTINUE SEMICOLON {: RESULT=new SingleStatementDerived4(); :}
				| RETURN OptionalExpression:O1 SEMICOLON {: RESULT=new SingleStatementDerived5(O1); RESULT.setLine(O1left); :}
				| READ LPAREN Designator:D1 RPAREN SEMICOLON {: RESULT=new SingleStatementDerived6(D1); RESULT.setLine(D1left); :}
				| PRINT LPAREN Expr:E1 OptionalNumConst:O2 RPAREN SEMICOLON {: RESULT=new SingleStatementDerived7(E1, O2); RESULT.setLine(E1left); :}
				| GOTO Label:L1 SEMICOLON {: RESULT=new SingleStatementDerived8(L1); RESULT.setLine(L1left); :};
				
OptionalElse ::= (OptionalElsec) ELSE Statement:S1 {: RESULT=new OptionalElsec(S1); RESULT.setLine(S1left); :}
				| (NoOptionalElse) {: RESULT=new NoOptionalElse(); :} /* epsilon */;

OptionalExpression ::= (OptionalExpressionc) Expr:E1 {: RESULT=new OptionalExpressionc(E1); RESULT.setLine(E1left); :} 
					| (NoOptionalExpression) {: RESULT=new NoOptionalExpression(); :} /* epsilon */;

OptionalNumConst ::= (OptionalNumConstc) COMMA NUMBER:N1 {: RESULT=new OptionalNumConstc(N1); RESULT.setLine(N1left); :}
				| (NoOptionalNumConst) {: RESULT=new NoOptionalNumConst(); :} /* epsilon */;
				
				
Statements ::= (Statementsc) LBRACECURLY StatementList:S1 RBRACECURLY {: RESULT=new Statementsc(S1); RESULT.setLine(S1left); :};
StatementList ::= (StatementListc) StatementList:S1 Statement:S2 {: RESULT=new StatementListc(S1, S2); RESULT.setLine(S1left); :}
				| (NoStatementList) {: RESULT=new NoStatementList(); :} /* epsilon */;				
				
DesignatorStatement ::= (DesignatorStatementc) Designator:D1 DesignatorStatementElements:D2 {: RESULT=new DesignatorStatementc(D1, D2); RESULT.setLine(D1left); :};				
				
DesignatorStatementElements ::= (DesignatorStatementElementsc) Assignop:A1 Expr:E2 {: RESULT=new DesignatorStatementElementsc(A1, E2); RESULT.setLine(A1left); :}
					| LPAREN ActParsOptional:A1 RPAREN {: RESULT=new DesignatorStatementElementsDerived1(A1); RESULT.setLine(A1left); :} 
					| INCREMENT {: RESULT=new DesignatorStatementElementsDerived2(); :}
					| DECREMENT {: RESULT=new DesignatorStatementElementsDerived3(); :};				


ActParsOptional ::= (ActParsOptionalc) ActPars:A1 {: RESULT=new ActParsOptionalc(A1); RESULT.setLine(A1left); :} 
				| (NoActPars) {: RESULT=new NoActPars(); :} /* epsilon */;


ActPars ::= (ActParsc) Expr:E1 ExprCommaList:E2 {: RESULT=new ActParsc(E1, E2); RESULT.setLine(E1left); :};

ExprCommaList ::= (ExprCommaListc) ExprCommaList:E1 COMMA Expr:E2 {: RESULT=new ExprCommaListc(E1, E2); RESULT.setLine(E1left); :} 
				| (NoExprCommaList) {: RESULT=new NoExprCommaList(); :} /* epsilon */;


Condition ::= (Conditionc) CondTerm:C1 CondTermListOr:C2 {: RESULT=new Conditionc(C1, C2); RESULT.setLine(C1left); :};
CondTermListOr ::= (CondTermListOrc) CondTermListOr:C1 OR CondTerm:C2 {: RESULT=new CondTermListOrc(C1, C2); RESULT.setLine(C1left); :}
				| (NoCondTermListOr) {: RESULT=new NoCondTermListOr(); :} /* epsilon */;

CondTerm ::= (CondTermc) CondFact:C1 CondFactListAnd:C2 {: RESULT=new CondTermc(C1, C2); RESULT.setLine(C1left); :};
CondFactListAnd ::= (CondFactListAndc) CondFactListAnd:C1 AND CondFact:C2 {: RESULT=new CondFactListAndc(C1, C2); RESULT.setLine(C1left); :}
				| (NoCondFactListAnd) {: RESULT=new NoCondFactListAnd(); :} /* epsilon */;
				
CondFact ::= (CondFactc) Expr:E1 RelopOprOptional:R2 {: RESULT=new CondFactc(E1, R2); RESULT.setLine(E1left); :};				 
				
RelopOprOptional ::= (RelopOprOptionalc) Relop:R1 Expr:E2 {: RESULT=new RelopOprOptionalc(R1, E2); RESULT.setLine(R1left); :}
				| (NoRelopOprOptional) {: RESULT=new NoRelopOprOptional(); :} /* epsilon */;				
				
				
Expr ::= (Exprc) OptionalMinus:O1 Term:T2 AddopTermList:A3 {: RESULT=new Exprc(O1, T2, A3); RESULT.setLine(O1left); :};

OptionalMinus ::= (OptionalMinus) MINUS {: RESULT=new OptionalMinus(); :} 
			 | (NoOptionalMinus) {: RESULT=new NoOptionalMinus(); :} /* epsilon */;

AddopTermList ::= (AddopTermListc) AddopTermList:A1 Addop:A2 Term:T3 {: RESULT=new AddopTermListc(A1, A2, T3); RESULT.setLine(A1left); :}
				| (NoAddopTermList) {: RESULT=new NoAddopTermList(); :} /* epsilon */;

Term ::= (Termc) Factor:F1 MulopFactorList:M2 {: RESULT=new Termc(F1, M2); RESULT.setLine(F1left); :};

MulopFactorList ::= (MulopFactorListc) MulopFactorList:M1 Mulop:M2 Factor:F3 {: RESULT=new MulopFactorListc(M1, M2, F3); RESULT.setLine(M1left); :}
				| (NoMulopFactorList) {: RESULT=new NoMulopFactorList(); :} /* epsilon */;

Factor ::= (Factorc) Designator:D1 ActParsBracesOptional:A2 {: RESULT=new Factorc(D1, A2); RESULT.setLine(D1left); :}
		| NUMBER:N1 {: RESULT=new FactorDerived1(N1); RESULT.setLine(N1left); :}
		| CHARCONST {: RESULT=new FactorDerived2(); :}
		| BOOLCONST {: RESULT=new FactorDerived3(); :}
		| NEW Type:T1 ExprBracesOptional:E2 {: RESULT=new FactorDerived4(T1, E2); RESULT.setLine(T1left); :}
		| LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived5(E1); RESULT.setLine(E1left); :};
		
ActParsBracesOptional ::= (ActParsBracesOptionalc) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ActParsBracesOptionalc(A1); RESULT.setLine(A1left); :} 		
						| (NoActParsBracesOptional) {: RESULT=new NoActParsBracesOptional(); :} /* epsilon */;
		
ExprBracesOptional ::= (ExprBracesOptionalc) LBRACE Expr:E1 RBRACE {: RESULT=new ExprBracesOptionalc(E1); RESULT.setLine(E1left); :}
					| (NoExprBracesOptional) {: RESULT=new NoExprBracesOptional(); :} /* epsilon */;
					
					
Designator ::= (Designatorc) IDENT:I1 {: RESULT=new Designatorc(I1); RESULT.setLine(I1left); :} 
			| IDENT:I1 LBRACE Expr:E2 RBRACE {: RESULT=new DesignatorDerived1(I1, E2); RESULT.setLine(I1left); :}
			| IdentList:I1 {: RESULT=new DesignatorDerived2(I1); RESULT.setLine(I1left); :};

IdentList ::= (IdentListc) IDENT:I1 DOT IDENT:I2 {: RESULT=new IdentListc(I1, I2); RESULT.setLine(I1left); :}
		 	| IDENT:I1 DOT IDENT:I2 LBRACE Expr:E3 RBRACE {: RESULT=new IdentListDerived1(I1, I2, E3); RESULT.setLine(I1left); :};
			
DotOrExpr ::= (DotOrExprc) DOT IDENT:I1 {: RESULT=new DotOrExprc(I1); RESULT.setLine(I1left); :} 
			| LBRACE Expr:E1 RBRACE {: RESULT=new DotOrExprDerived1(E1); RESULT.setLine(E1left); :};
			
Label ::= (Labelc) IDENT:I1 {: RESULT=new Labelc(I1); RESULT.setLine(I1left); :};

Assignop ::= (Assignopc) ASSIGN {: RESULT=new Assignopc(); :};

Relop ::= (Relopc) EQUAL {: RESULT=new Relopc(); :}
		| NOTEQUAL {: RESULT=new RelopDerived1(); :}
		| GREATER {: RESULT=new RelopDerived2(); :}
		| GREATEREQUAL {: RESULT=new RelopDerived3(); :}
		| LOWER {: RESULT=new RelopDerived4(); :}
		| LOWEREQUAL {: RESULT=new RelopDerived5(); :};
		
Addop ::= (AddOpc) PLUS {: RESULT=new AddOpc(); :} | MINUS {: RESULT=new AddopDerived1(); :};

Mulop ::= (Mulopc) MUL {: RESULT=new Mulopc(); :} | DIV {: RESULT=new MulopDerived1(); :} | MOD {: RESULT=new MulopDerived2(); :};

