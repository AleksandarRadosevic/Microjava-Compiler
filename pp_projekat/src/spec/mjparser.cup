




package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal IDENT, NUMBER, PROG, LBRACECURLY, RBRACECURLY, CONST, ASSIGN, CHARCONST, BOOLCONST, EQUAL, NOTEQUAL, GREATER, GREATEREQUAL;
terminal COMMA, CLASS, EXTENDS, RECORD, LPAREN, RPAREN, VOID, PRINT, GOTO, AND, NEW, DOT, PLUS, MINUS, MUL, DIV, MOD, COLON;
terminal IF, SEMICOLON, DO, WHILE, BREAK, CONTINUE, RETURN, READ, LBRACE, RBRACE, INCREMENT, DECREMENT,LOWER, LOWEREQUAL, OR, ELSE;

nonterminal Program, DeclarationList, ConstDecl, VarDecl, ClassDecl, RecordDecl, Type, ConstVal, ConstDeclList, MethodDecl;
nonterminal OptionalBraces, VarDeclList, ConstDeclRepeat, VarDeclRepeat, OptionalExtends, DeclListVar, DeclList;
nonterminal OptConstructorMethod, ConstructorDecl, OptionalConstructorDecl, DeclListMethod, StatementList, TypeOrVoid;
nonterminal FormParsOptional, Statement, FormPars, Pars, ParsList, SingleStatement, OptionalLabelColon, Label, LabelColon;
nonterminal Condition, OptionalElse, Designator, DesignatorStatement, DesignatorStatementElements, ExprCommaList;
nonterminal Expr, OptionalNumConst, Statements, OptionalExpression, ActParsOptional, ActPars, CondTerm;
nonterminal CondTermListOr, CondFactListAnd, CondFact, RelopOprOptional, Relop, OptionalMinus, Term, AddopTermList;
nonterminal Addop, Factor, MulopFactorList, Mulop, ActParsBracesOptional, ExprBracesOptional, IdentList, DotOrExpr, Assignop;


Program ::= (Programc) PROG IDENT DeclarationList LBRACECURLY DeclListMethod RBRACECURLY;

DeclarationList ::= (DeclarationListc) DeclarationList DeclList
				| (NoDeclarations) /* epsilon */;
				
DeclList ::= (DeclListc)  
				ConstDecl  |
				VarDecl    | 
				ClassDecl  | 
				RecordDecl;
			

ConstDecl ::= (ConstDeclc) ConstDeclRepeat ConstDeclList SEMICOLON;

ConstDeclRepeat ::= (ConstDeclRepeatc) CONST Type:constType IDENT ASSIGN ConstVal;

ConstVal ::= (ConstValc) NUMBER | CHARCONST | BOOLCONST;

ConstDeclList ::= (ConstDeclListc) ConstDeclList ConstDeclRepeat  
				| (NoConstDecl) /* epsilon */;
	

VarDecl ::= (VarDeclc) VarDeclRepeat VarDeclList;

VarDeclRepeat ::= (VarDeclRepeatc) Type:varType IDENT OptionalBraces;

OptionalBraces ::= (OptionalBracesc) LBRACE RBRACE 
				| (NoOptionalBraces) /* epsilon */;

VarDeclList ::= (VarDeclListc) VarDeclList COMMA VarDeclRepeat  
				| (NoVarDeclList) /* epsilon */;
	
			
ClassDecl ::= (ClassDeclc) CLASS IDENT OptionalExtends LBRACECURLY DeclListVar OptConstructorMethod RBRACECURLY;			 

OptionalExtends ::= (OptionalExtendsc) EXTENDS Type;
 
DeclListVar ::=	(DeclListVarc) DeclListVar VarDecl 
				| (NoDeclListVar) /* epsilon */;	


OptConstructorMethod ::= (OptConstructorMethodc) LBRACECURLY OptionalConstructorDecl DeclListMethod RBRACECURLY
				| (NoOptConstructorMethod) /* epsilon */;	
				
OptionalConstructorDecl ::= (OptionalConstructorDeclc) ConstructorDecl
				| (NoOptionalConstructorDecl) /* epsilon */;	
				
DeclListMethod ::= (DeclListMethodc) DeclListMethod MethodDecl 
				| (NoDeclListMethod) /* epsilon */;	


RecordDecl ::= (RecordDeclc) RECORD IDENT LBRACECURLY DeclListVar RBRACECURLY;

ConstructorDecl ::= (ConstructorDeclc) IDENT LPAREN RPAREN DeclListVar LBRACECURLY StatementList RBRACECURLY;


MethodDecl ::= (MethodDeclc) TypeOrVoid IDENT LPAREN FormParsOptional RPAREN DeclListVar LBRACECURLY StatementList RBRACECURLY;

TypeOrVoid ::= (TypeOrVoidc) Type | VOID;

FormParsOptional ::= (FormParsOptionalc) FormPars
				| (NoFormParsOptional) /* epsilon */;
						
						
FormPars ::= (FormParsc) Pars ParsList;
		
Pars ::= (Parsc) Type IDENT OptionalBraces;

ParsList ::= (ParsListc) ParsList COMMA Pars 
			| (NoParsList) /* epsilon */;

Type ::= IDENT;


Statement ::= (Statementc) OptionalLabelColon SingleStatement 
			| Statements;

OptionalLabelColon ::= (OptionalLabelColonc) LabelColon 
					| (NoOptionalLabelColon) /* epsilon */;

LabelColon ::= (LabelColonc) Label COLON;

SingleStatement ::= (SingleStatementc) DesignatorStatement SEMICOLON
				| IF LPAREN Condition RPAREN Statement OptionalElse
			 	| DO Statement WHILE LPAREN RPAREN Condition SEMICOLON
				| BREAK SEMICOLON
				| CONTINUE SEMICOLON
				| RETURN OptionalExpression SEMICOLON
				| READ LPAREN Designator RPAREN SEMICOLON
				| PRINT LPAREN Expr OptionalNumConst RPAREN SEMICOLON
				| GOTO Label SEMICOLON;
				
OptionalElse ::= (OptionalElsec) ELSE Statement
				| (NoOptionalElse) /* epsilon */;

OptionalExpression ::= (OptionalExpressionc) Expr 
					| (NoOptionalExpression) /* epsilon */;

OptionalNumConst ::= (OptionalNumConstc) COMMA NUMBER
				| (NoOptionalNumConst) /* epsilon */;
				
				
Statements ::= (Statementsc) LBRACECURLY StatementList RBRACECURLY;
StatementList ::= (StatementListc) StatementList Statement
				| (NoStatementList) /* epsilon */;				
				
DesignatorStatement ::= (DesignatorStatementc) Designator DesignatorStatementElements;				
				
DesignatorStatementElements ::= (DesignatorStatementElementsc) Assignop Expr
					| LPAREN ActParsOptional RPAREN 
					| INCREMENT
					| DECREMENT;				


ActParsOptional ::= (ActParsOptionalc) ActPars 
				| (NoActPars) /* epsilon */;


ActPars ::= (ActParsc) Expr ExprCommaList;

ExprCommaList ::= (ExprCommaListc) ExprCommaList COMMA Expr 
				| (NoExprCommaList) /* epsilon */;


Condition ::= (Conditionc) CondTerm CondTermListOr;
CondTermListOr ::= (CondTermListOrc) CondTermListOr OR CondTerm
				| (NoCondTermListOr) /* epsilon */;

CondTerm ::= (CondTermc) CondFact CondFactListAnd;
CondFactListAnd ::= (CondFactListAndc) CondFactListAnd AND CondFact
				| (NoCondFactListAnd) /* epsilon */;
				
CondFact ::= (CondFactc) Expr RelopOprOptional;				 
				
RelopOprOptional ::= (RelopOprOptionalc) Relop Expr
				| (NoRelopOprOptional) /* epsilon */;				
				
				
Expr ::= (Exprc) OptionalMinus Term AddopTermList;

OptionalMinus ::= (OptionalMinus) MINUS 
			 | (NoOptionalMinus) /* epsilon */;

AddopTermList ::= (AddopTermListc) AddopTermList Addop Term
				| (NoAddopTermList) /* epsilon */;

Term ::= (Termc) Factor MulopFactorList;

MulopFactorList ::= (MulopFactorListc) MulopFactorList Mulop Factor
				| (NoMulopFactorList) /* epsilon */;

Factor ::= (Factorc) Designator ActParsBracesOptional
		| NUMBER
		| CHARCONST
		| BOOLCONST
		| NEW Type ExprBracesOptional
		| LPAREN Expr RPAREN;
		
ActParsBracesOptional ::= (ActParsBracesOptionalc) LPAREN ActParsOptional RPAREN 		
						| (NoActParsBracesOptional) /* epsilon */;
		
ExprBracesOptional ::= (ExprBracesOptionalc) LBRACE Expr RBRACE	
					| (NoExprBracesOptional) /* epsilon */;
					
					
Designator ::= (Designatorc) IDENT IdentList;

IdentList ::= (IdentListc) IdentList DotOrExpr
		 	| (NoIdentList) /* epsilon */;
			
DotOrExpr ::= (DotOrExprc) DOT IDENT 
			| LBRACE Expr RBRACE;
			
Label ::= (Labelc) IDENT;

Assignop ::= (Assignopc) ASSIGN;

Relop ::= (Relopc) EQUAL
		| NOTEQUAL
		| GREATER
		| GREATEREQUAL
		| LOWER
		| LOWEREQUAL;
		
Addop ::= (AddOpc) PLUS | MINUS;

Mulop ::= (Mulopc) MUL | DIV | MOD;

